#+TITLE: First order autodiff 



* Component wise

Exposition use 1-based indices.

We want to compute differential of 
$$
F_k:\mathbb{R}^{n_1}\to \mathbb{R}^{n_k}
$$

We assume that it exists elementary transforms: 
\begin{equation*}
\Phi_k:\mathbb{R}^{n_k}\to \mathbb{R}^{n_{k+1}}
\end{equation*}
such that:
\begin{equation*}
F_k=\Phi_{k-1}\circ \Phi_{k-2} \circ \dots \circ \Phi_{1}
\end{equation*}
More in details the elementary transforms $\Phi_k$ takes the form:
\begin{equation*}
\Phi_{k}(x\in\mathbb{R}^{n_k})=\left(x^1,\dots,x^{n_k},(\varphi_k)^{n_k+1}(x),\dots ,(\varphi_k)^{n_{k+1}}(x)\right)
\end{equation*}
In other terms $n_{k+1}-n_k$ components are created from $x$ and added
to the first $n_k$ ones. 

If we further assume that $n_{k+1}=n_k+1$ which means that components
are created one by one, then 
\begin{equation*}
\Phi_{k}(x\in\mathbb{R}^{n_k})=\left(x^1,\dots,x^{n_k},(\varphi_k)^{n_k+1}(x)\right)
\end{equation*}
and $d\Phi_{k}$ takes the form:

\begin{equation*}
\label{eq_dPhi}
d\Phi_k=\left(
\begin{array}{cccc}
1        & 0      & \dots  & 0 \\
0        & \ddots &        & \vdots \\
\vdots   &        & \ddots & 0 \\
0        & \dots  & 0      & 1 \\
\hline
\dots         & \partial_j (\varphi_k)^{n_k+1}  & \dots      & 0 
\end{array}
\right)_{(n_k+1)\times n_k}
\end{equation*}

where $j=1..n_k$

# We have:
# \begin{equation*}
# \Phi=\Phi_{n}\circ \Phi_{n-1}\circ \Phi_{n-2} \circ \dots \circ \Phi_{1}
# \end{equation*}


* Forward pass

To compute 

\begin{equation*}
F_k=\Phi_{k}\circ \Phi_{k-1}\circ \Phi_{k-2} \circ \dots \circ \Phi_{1}
\end{equation*}

One can notice that $F_1=\Phi_1$, $F_2=\Phi_2\circ\Phi_1=\Phi_2\circ F_1$ and
so on... there is a recurrence relation:
\begin{equation*}
F_k=\Phi_{k}\circ F_{k-1},\ \ F_0=Id
\end{equation*}
Using chain rule:
\begin{equation}
\label{eq_chain_rule}
dF_k(x)=d\Phi_{k}(F_{k-1}(x))\circ dF_{k-1}(x)
\end{equation}

If we unroll this last relation and use $F_0=Id_{n1}$; $dF_{0}(x)=Id_{n1}$, we get:
\begin{align*}
dF_k(x) & = d\Phi_{k}(F_{k-1}(x))\circ d\Phi_{k-1}(F_{k-2}(x))\circ \dots \circ d\Phi_{1}(F_{0}(x)) dF_{0}(x) \\
	& = d\Phi_{k}(F_{k-1}(x))\circ d\Phi_{k-1}(F_{k-2}(x))\circ \dots \circ d\Phi_{1}(x) 
\end{align*}

If one computes $(dF_k).e_j$, we get one *column* $(dF_k)^j_{i=1\dots n_k:$. However
in optimization we want to compute $(dF_n)$ row $i$. This row can be
computed by $(dF_n)^t.e_i$

From Eq. \ref{eq_chain_rule}, \begin{equation*}
\label{eq_chain_rule}
(dF_k)^t(x)=(dF_{k-1})^t(x)\circ d(\Phi_{k})^t(F_{k-1}
\end{equation*}

* Implementation details [0/1]

** TODO =JamesBond_Mark=

In order to manage nested auto diff one must define 

#+begin_src c++ :eval never
template <typename TYPE>
class JamesBond_Mark;

template <typename T>
class JamesBond_Mark<T>
{
  offset_type _offset;  // <- offset for Tape<T>

  ~JamesBond_Mark() { tape<T>().rewind(_offset); }
};

template <typename T>
class JamesBond_Mark<Ad<T>>
{
  offset_type _offset;           // <- offset for Tape<Ad<T>>
  JamesBond_Mark<T> _recursive;  // <- offset for Tape<T>

  ~JamesBond_Mark() { tape<Ad<T>>().rewind(_offset); }
};
#+end_src
