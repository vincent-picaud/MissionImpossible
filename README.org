#+TITLE: Mission : Impossible (self-destructing AD local tape...)

* What is it?

*Mission : Impossible* is a concise and fast C++17 implementation of automatic
differentiation based on operator overloading. It is adapted for
general purpose small to mid size problems. 

For repeated calculations it is very easy to define an
auto-destructive local tape, hence the wink to the "Mission:
Impossible" series.

#+begin_center
[[file:figures/tape.jpeg][file:./figures/tape.jpeg]]
#+end_center

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/local_tape.cpp
#+END_SRC

#+RESULTS:
#+begin_src cpp :eval never
#include "MissionImpossible/MissionImpossible.hpp"

#include <iostream>

using namespace MissionImpossible;

void
example(const double x,
        const double mu,
        const double sigma,
        double& f,
        double& grad_f_mu,
        double& grad_f_sigma)
{
  MissionImpossible_Tape<double> local_tape;  // a local thread_local tape

  AD<double> ad_mu(mu), ad_sigma(sigma), ad_f;

  ad_f = 2 * exp(-(x - ad_mu) / pow(ad_sigma, 2));

  auto ad_grad_f = gradient(ad_f);

  f            = ad_f.value();
  grad_f_mu    = ad_grad_f[ad_mu];
  grad_f_sigma = ad_grad_f[ad_sigma];

  // here the local tape is destroyed (in fact re-winded to avoid
  // useless new/delete)
}

int
main()
{
  double x = 1, mu = 2, sigma = 3;
  double f, grad_f_mu, grad_f_sigma;

  example(x, mu, sigma, f, grad_f_mu, grad_f_sigma);

  std::cout << "f= " << f << std::endl;
  std::cout << "∇f= " << grad_f_mu << ", " << grad_f_sigma;
}
#+end_src

This library has been optimized (meta-programming) for unstructured 
first order derivatives. I have to produce benchmark plots, but its
speed must be comparable to [[https://github.com/rjhogan/Adept-2][Adept]] as it relies on the same kind of
approach [1].

#+begin_quote
[1], Srajer, Filip, Zuzana Kukelova, and Andrew Fitzgibbon. "A
benchmark of selected algorithmic differentiation tools on some
problems in computer vision and machine learning." Optimization
Methods and Software 33.4-6 (2018): 889-906.
#+end_quote

Even if the library has not been optimized for these cases, it
naturally supports nested calculation of higher order
derivatives. However, note that in this situation dedicated
approaches like [2,3] which takes into account symmetries are more
suited.

#+begin_quote
[2], Wang, Mu, Assefaw Gebremedhin, and Alex Pothen. "Capitalizing on
live variables: new algorithms for efficient Hessian computation via
automatic differentiation." Mathematical Programming Computation 8.4
(2016): 393-433.
#+end_quote

#+begin_quote
[3], Gower, Robert Mansel, and Artur L. Gower. "Higher-order reverse
automatic differentiation with emphasis on the third-order."
Mathematical Programming 155.1-2 (2016): 81-103.
#+end_quote

** News

   - [2020-01-07 Tue 12:27] \\
     This a *pre-release* for the curious. Some developments remain to be
     done (implementing special functions, adding examples and benchmarks)
     but the design and API is not expected to change a lot.

* Compilation

The library currently uses the [[https://mesonbuild.com/][meson]] build system.

If you are not familiar with meson, the compilation procedure is as
follows:

#+BEGIN_SRC sh :eval never
git clone git@github.com:vincent-picaud/MissionImpossible.git
cd MissionImpossible/
meson build
cd build
ninja test
#+END_SRC 

Examples can then be found in the =build/examples/= directory.

** Release

To get an *optimized* version, use:

#+BEGIN_SRC sh :eval never
meson --buildtype=release -Db_ndebug=true build-release
#+END_SRC

* Examples
** Jacobian example

Illustrates *forward-mode* and *reverse-mode* support. The first one is
convenient to compute the Jacobian is computed column by column. The
second one is effective to compute gradients or Jacobian row by row.

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/Jacobian.cpp
#+END_SRC

#+RESULTS:
#+begin_src cpp :eval never
#include "MissionImpossible/MissionImpossible.hpp"

#include <iostream>

using namespace MissionImpossible;

int
main()
{
  AD<double> r = 2, theta = 0.1;

  AD<double> y1 = r * cos(theta);
  AD<double> y2 = r * sin(theta);

  //////////////////////////////////
  // Computes Jacobian row by row //
  //////////////////////////////////
  //
  // -> AKA reverse-mode
  //
  std::cout << "Jacobian row by row" << std::endl;

  auto Jacobian_row_y1 = Jacobian_row(y1);  // ∇y1

  std::cout << "∇y1(r,θ) = " << std::setw(20) << Jacobian_row_y1[r] << ", ";
  std::cout << std::setw(20) << Jacobian_row_y1[theta] << std::endl;

  auto Jacobian_row_y2 = Jacobian_row(y2);  // ∇y2

  std::cout << "∇y2(r,θ) = " << std::setw(20) << Jacobian_row_y2[r] << ", ";
  std::cout << std::setw(20) << Jacobian_row_y2[theta] << std::endl;

  ////////////////////////////////////////
  // Computes Jacobian column by column //
  ////////////////////////////////////////
  //
  // -> AKA forward-mode
  //
  std::cout << std::endl << "Jacobian column by column" << std::endl;

  auto Jacobian_column_r = Jacobian_column(r);  // r column

  std::cout << "∂r y1  = " << std::setw(20) << Jacobian_column_r[y1] << std::endl;
  std::cout << "∂r y2  = " << std::setw(20) << Jacobian_column_r[y2] << std::endl;

  auto Jacobian_column_theta = Jacobian_column(theta);  // θ column

  std::cout << "∂θ y1  = " << std::setw(20) << Jacobian_column_theta[y1] << std::endl;
  std::cout << "∂θ y2  = " << std::setw(20) << Jacobian_column_theta[y2] << std::endl;
}
#+end_src

which prints

#+begin_example
acobian row by row
∇y1(r,θ) =             0.995004,            -0.199667
∇y2(r,θ) =            0.0998334,              1.99001

Jacobian column by column
∂r y1  =             0.995004
∂r y2  =            0.0998334
∂θ y1  =            -0.199667
∂θ y2  =              1.99001
#+end_example

** Hessian action Hv, directional derivatives

Illustrate Hessian action Hv=∇ <∇f,v> computation:

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/Hv.cpp
#+END_SRC

#+RESULTS:
#+begin_src cpp :eval never
#include "MissionImpossible/MissionImpossible.hpp"

using namespace MissionImpossible;

int
main()
{
  AD<AD<double>> x0(3), x1(4), y;

  y = (1 - x0) * (1 - x0) + 10 * (x1 - x0 * x0) * (x1 - x0 * x0);

  std::cout << "f=  " << y << std::endl;

  auto y_gradient = gradient(y);  // Computes ∇f

  std::cout << "∇f= " << y_gradient[x0] << ", ";
  std::cout << y_gradient[x1] << std::endl;

  AD<double> z;

  double v0(5), v1(6);

  z = v0 * y_gradient[x0] + v1 * y_gradient[x1];  // Computes z=<∇f,v>

  auto z_gradient = gradient(z);  // Computes Hv = ∇z = ∇ <∇f,v>

  std::cout << "Hv= " << z_gradient[x0] << ", ";
  std::cout << z_gradient[x1] << std::endl;
}
#+end_src

** Third order example 

Illustrates that the library supports nested computations

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/nested.cpp
#+END_SRC

#+RESULTS:
#+begin_src cpp :eval never
#include "MissionImpossible/MissionImpossible.hpp"

#include <iostream>

using namespace MissionImpossible;

template <typename T>
auto
Rosenbrock(const T& x0, const T& x1)
{
  return (1 - x0) * (1 - x0) + 10 * (x1 - x0 * x0) * (x1 - x0 * x0);
}

// Third order demo
int
main()
{
  AD<AD<AD<double>>> x0(3), x1(4), y;

  y = Rosenbrock(x0, x1);

  auto grad = gradient(y);

  auto Hessian_x0_row = gradient(grad[x0]);
  auto Hessian_x1_row = gradient(grad[x1]);

  auto third_order_x0_x0_row = gradient(Hessian_x0_row[x0]);
  auto third_order_x0_x1_row = gradient(Hessian_x0_row[x1]);
  auto third_order_x1_x0_row = gradient(Hessian_x1_row[x0]);
  auto third_order_x1_x1_row = gradient(Hessian_x1_row[x1]);

  std::cout << "f     = " << y << std::endl;
  std::cout << std::endl;
  std::cout << "∂₀f   = " << grad[x0] << std::endl;
  std::cout << "∂₁f   = " << grad[x1] << std::endl;
  std::cout << std::endl;
  std::cout << "∂²₀₀f = " << Hessian_x0_row[x0] << std::endl;
  std::cout << "∂²₀₁f = " << Hessian_x0_row[x1] << std::endl;
  std::cout << "∂²₁₀f = " << Hessian_x1_row[x0] << std::endl;
  std::cout << "∂²₁₁f = " << Hessian_x1_row[x1] << std::endl;
  std::cout << std::endl;
  std::cout << "∂³₀₀₀f = " << third_order_x0_x0_row[x0] << std::endl;
  std::cout << "∂³₀₀₁f = " << third_order_x0_x0_row[x1] << std::endl;
  std::cout << "∂³₀₁₀f = " << third_order_x0_x1_row[x0] << std::endl;
  std::cout << "∂³₀₁₁f = " << third_order_x0_x1_row[x1] << std::endl;
  std::cout << "∂³₁₀₀f = " << third_order_x1_x0_row[x0] << std::endl;
  std::cout << "∂³₁₀₁f = " << third_order_x1_x0_row[x1] << std::endl;
  std::cout << "∂³₁₁₀f = " << third_order_x1_x1_row[x0] << std::endl;
  std::cout << "∂³₁₁₁f = " << third_order_x1_x1_row[x1] << std::endl;
}
#+end_src

which prints
#+begin_example
f     = +254

∂₀f   = +604
∂₁f   = -100

∂²₀₀f = +922
∂²₀₁f = -120
∂²₁₀f = -120
∂²₁₁f = +20

∂³₀₀₀f = +720
∂³₀₀₁f = -40
∂³₀₁₀f = -40
∂³₀₁₁f = +0
∂³₁₀₀f = -40
∂³₁₀₁f = +0
∂³₁₁₀f = +0
∂³₁₁₁f = +0
#+end_example
