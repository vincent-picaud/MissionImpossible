#+TITLE: Mission : impossible, Automatic Differentiation

Check:

#+RESULTS:
* Compilation
** Release
#+BEGIN_SRC sh :eval never
meson --buildtype=release -Db_ndebug=on build-release
#+END_SRC

* Examples
** Hessian action $H.v$

Observe that
$$
H.v=\nabla_X \langle v,\nabla_X f \rangle
$$

$$
\nabla_X v . \nabla_X f = \nabla_X  \langle v, \sum_j \partial_j f \rangle =\sum_{ij} v_i \partial_{ij}f = H.v
$$

The associated code is

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/test/Hv.cpp
#+END_SRC

#+begin_src cpp :eval never
#include "AutoDiffCpp/ad.hpp"
#include "AutoDiffCpp/derivatives.hpp"

#include <gtest/gtest.h>
#include <vector>

using namespace AutoDiffCpp;

// Idea H.v = ∇_w(v.∇_w f)
// See: http://www.bcl.hamilton.ie/~barak/papers/nc-hessian.pdf
TEST(Nested, Hv)
{
  AD<AD<double>> x0(3), x1(4), y;
  y = (1 - x0) * (1 - x0) + 10 * (x1 - x0 * x0) * (x1 - x0 * x0);

  assert(y == 254);

  auto y_gradient = Jacobian_row(y);  // Compute ∇_w f

  assert(y_gradient[x0] == 604);
  assert(y_gradient[x1] == -100);

  AD<double> v0(5), v1(6), z;
  z = v0 * y_gradient[x0] + v1 * y_gradient[x1];  // Compute v.∇_w f

  auto z_gradient = Jacobian_row(z);  // Compute ∇_w(v.∇_w f) = H.v

  assert(z_gradient[x0] == 3890);
  assert(z_gradient[x1] == -480);
}
#+end_src
