#+TITLE: Mission : impossible, Automatic Differentiation

* Compilation
** Release
#+BEGIN_SRC sh :eval never
meson --buildtype=release -Db_ndebug=true build-release
#+END_SRC

* Examples
** Jacobian example
The library supports reverse-mode, useful to compute gradient or
Jacobian row by row. It also supports forward-mode where the Jacobian
is computed column by column.

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/Jacobian.cpp
#+END_SRC

#+RESULTS:
#+begin_src cpp :eval never
#include "Mission_Impossible_AutoDiff/Mission_Impossible.hpp"

#include <iostream>

using namespace Mission_Impossible_AutoDiff;

int
main()
{
  AD<double> r, theta;

  r     = 2;
  theta = 0.1;

  AD<double> y1 = r * cos(theta);
  AD<double> y2 = r * sin(theta);

  //////////////////////////////////
  // Computes Jacobian row by row //
  //////////////////////////////////
  //
  // -> AKA reverse-mode
  //
  std::cout << std::endl << "Jacobian row by row" << std::endl;

  // y1 row (which is also ∇y1)
  // -> you can also replace "Jacobian_row(y1)" by "gradient(y1)"
  //
  auto Jacobian_row_y1 = Jacobian_row(y1);

  std::cout << "∇y1[r] = " << std::setw(20) << Jacobian_row_y1[r]
            << " (must be cos(θ) = " << cos(theta) << ")" << std::endl;
  std::cout << "∇y1[θ] = " << std::setw(20) << Jacobian_row_y1[theta]
            << " (must be -r*sin(θ) = " << -r * sin(theta) << ")" << std::endl;

  // In the same way, one can compute ∇y2
  //
  auto Jacobian_row_y2 = Jacobian_row(y2);

  std::cout << "∇y2[r] = " << std::setw(20) << Jacobian_row_y2[r]
            << " (must be sin(θ) = " << sin(theta) << ")" << std::endl;
  std::cout << "∇y2[θ] = " << std::setw(20) << Jacobian_row_y2[theta]
            << " (must be +r*cos(θ) = " << r * cos(theta) << ")" << std::endl;

  ////////////////////////////////////////
  // Computes Jacobian column by column //
  ////////////////////////////////////////
  //
  // -> AKA forward-mode
  //
  std::cout << std::endl << "Jacobian column by column" << std::endl;

  // r column
  //
  auto Jacobian_column_r = Jacobian_column(r);

  std::cout << "∂r y1  = " << std::setw(20) << Jacobian_column_r[y1]
            << " (must be cos(θ) = " << cos(theta) << ")" << std::endl;
  std::cout << "∂r y2  = " << std::setw(20) << Jacobian_column_r[y2]
            << " (must be sin(θ) = " << sin(theta) << ")" << std::endl;

  // θ column
  //
  auto Jacobian_column_theta = Jacobian_column(theta);

  std::cout << "∂θ y1  = " << std::setw(20) << Jacobian_column_theta[y1]
            << " (must be -r*sin(θ) = " << -r * sin(theta) << ")" << std::endl;
  std::cout << "∂θ y2  = " << std::setw(20) << Jacobian_column_theta[y2]
            << " (must be +r*cos(θ) = " << r * cos(theta) << ")" << std::endl;
}
#+end_src

which prints

#+begin_example
Jacobian row by row
∇y1[r] =             0.995004 (must be cos(θ) = 0.995004)
∇y1[θ] =            -0.199667 (must be -r*sin(θ) = -0.199667)
∇y2[r] =            0.0998334 (must be sin(θ) = 0.0998334)
∇y2[θ] =              1.99001 (must be +r*cos(θ) = 1.99001)

Jacobian column by column
∂r y1  =             0.995004 (must be cos(θ) = 0.995004)
∂r y2  =            0.0998334 (must be sin(θ) = 0.0998334)
∂θ y1  =            -0.199667 (must be -r*sin(θ) = -0.199667)
∂θ y2  =              1.99001 (must be +r*cos(θ) = 1.99001)
#+end_example

** Hessian action H.v

Observe that H.v=\nabla_{X} < v,\nabla_{X} f >

\begin{equation}
\nabla_{X} v . \nabla_{X} f = \nabla_{X}  \langle v, \sum_{j} \partial_{j} f \rangle =\sum_{ij} v_i \partial_{ij}f = H.v
\end{equation}

The associated code is

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/test/Hv.cpp
#+END_SRC

#+RESULTS:
#+BEGIN_src cpp :eval never
#include "AutoDiffCpp/ad.hpp"
#include "AutoDiffCpp/derivatives.hpp"

#include <gtest/gtest.h>
#include <vector>

using namespace AutoDiffCpp;

// Idea H.v = ∇_w(v.∇_w f)
// See: http://www.bcl.hamilton.ie/~barak/papers/nc-hessian.pdf
TEST(Nested, Hv)
{
  AD<AD<double>> x0(3), x1(4), y;
  y = (1 - x0) * (1 - x0) + 10 * (x1 - x0 * x0) * (x1 - x0 * x0);

  assert(y == 254);

  auto y_gradient = Jacobian_row(y);  // Compute ∇_w f

  assert(y_gradient[x0] == 604);
  assert(y_gradient[x1] == -100);

  AD<double> z;
  double v0(5), v1(6);
  z = v0 * y_gradient[x0] + v1 * y_gradient[x1];  // Compute v.∇_w f

  auto z_gradient = Jacobian_row(z);  // Compute ∇_w(v.∇_w f) = H.v

  assert(z_gradient[x0] == 3890);
  assert(z_gradient[x1] == -480);
}
#+END_src
** Third order example 

The library supports the nested calculation of higher order
derivatives. Note however, that it has not been specially optimized
for this use, especially when taking into account symmetries.

#+BEGIN_SRC sh :wrap "src cpp :eval never" :results output :exports results
cat $(pwd)/examples/nested.cpp
#+END_SRC

#+RESULTS:
#+begin_src cpp :eval never
#include "Mission_Impossible_AutoDiff/Mission_Impossible.hpp"

#include <iostream>

using namespace Mission_Impossible_AutoDiff;

template <typename T>
auto
Rosenbrock(const T& x0, const T& x1)
{
  return (1 - x0) * (1 - x0) + 10 * (x1 - x0 * x0) * (x1 - x0 * x0);
}

// Third order demo
int
main()
{
  AD<AD<AD<double>>> x0(3), x1(4), y;

  y = Rosenbrock(x0, x1);

  auto grad = gradient(y);

  auto Hessian_x0_row = gradient(grad[x0]);
  auto Hessian_x1_row = gradient(grad[x1]);

  auto third_order_x0_x0_row = gradient(Hessian_x0_row[x0]);
  auto third_order_x0_x1_row = gradient(Hessian_x0_row[x1]);
  auto third_order_x1_x0_row = gradient(Hessian_x1_row[x0]);
  auto third_order_x1_x1_row = gradient(Hessian_x1_row[x1]);

  std::cout << "f     = " << y << std::endl;
  std::cout << std::endl;
  std::cout << "∂₀f   = " << grad[x0] << std::endl;
  std::cout << "∂₁f   = " << grad[x1] << std::endl;
  std::cout << std::endl;
  std::cout << "∂²₀₀f = " << Hessian_x0_row[x0] << std::endl;
  std::cout << "∂²₀₁f = " << Hessian_x0_row[x1] << std::endl;
  std::cout << "∂²₁₀f = " << Hessian_x1_row[x0] << std::endl;
  std::cout << "∂²₁₁f = " << Hessian_x1_row[x1] << std::endl;
  std::cout << std::endl;
  std::cout << "∂³₀₀₀f = " << third_order_x0_x0_row[x0] << std::endl;
  std::cout << "∂³₀₀₁f = " << third_order_x0_x0_row[x1] << std::endl;
  std::cout << "∂³₀₁₀f = " << third_order_x0_x1_row[x0] << std::endl;
  std::cout << "∂³₀₁₁f = " << third_order_x0_x1_row[x1] << std::endl;
  std::cout << "∂³₁₀₀f = " << third_order_x1_x0_row[x0] << std::endl;
  std::cout << "∂³₁₀₁f = " << third_order_x1_x0_row[x1] << std::endl;
  std::cout << "∂³₁₁₀f = " << third_order_x1_x1_row[x0] << std::endl;
  std::cout << "∂³₁₁₁f = " << third_order_x1_x1_row[x1] << std::endl;
}
#+end_src

which prints
#+begin_example
f     = +254

∂₀f   = +604
∂₁f   = -100

∂²₀₀f = +922
∂²₀₁f = -120
∂²₁₀f = -120
∂²₁₁f = +20

∂³₀₀₀f = +720
∂³₀₀₁f = -40
∂³₀₁₀f = -40
∂³₀₁₁f = +0
∂³₁₀₀f = -40
∂³₁₀₁f = +0
∂³₁₁₀f = +0
∂³₁₁₁f = +0
#+end_example
